# Interoperability

The ability for a blockchain to easily read the state of another blockchain is called interoperability.
Low latency interoperability allows for horizontally scalable blockchains, a key feature of the superchain.

Note: this document references an "interop network upgrade" as a temporary name. The actual name of the
network upgrade will be included in this document in the future.

## Overview

| Term          | Definition                                               |
|---------------|----------------------------------------------------------|
| Local Chain   | A blockchain that includes an initiating message |
| Remote Chain  | A blockchain that includes a relaying message |
| Initiating Message | A transaction submitted to a local chain that authorizes execution on a remote chain |
| Relaying Message | A transaction submitted to a remote chain that corresponds to an initiating message |
| Cross Chain Message | The cumulative execution and side effects of the initiating message and relaying message |
| Interop Set | The set of chains that originate initiating transactions where the relaying transactions are valid |

A total of two transactions are required to complete a cross chain message. The first transaction is submitted
to the local chain which authorizes execution on a remote chain. The second transaction is submitted to a
remote chain, where the block builder SHOULD only include it if they are certain that the first transaction was
included in the local chain.

The term "block builder" is used interchangeably with the term "sequencer" for the purposes of this document but they need not be the same
entity in practice.

## The Interop Set

The interop set defines the set of chains that a remote chains allows as local chains. Another way of
saying it is that the interop set defines the set of initiating messages that are valid for a relaying
message to be included. A relaying message MUST have an initiating message that is included in a chain
in the interop set.

The interop set is defined by chain id. Since it is impossible to enforce uniqueness of chain ids,
social consensus MUST be used to determine the chain that represents the canonical chain id. This
particularly impacts the block builder as they SHOULD use the chain id to assist in validation
of relaying messages. 

### Chain ID

The concept of a chain id was introduced in [EIP-155](https://eips.ethereum.org/EIPS/eip-155) to prevent
replay attacks between chains. This EIP does not specify the max size of a chain id, although
[EIP-2294](https://eips.ethereum.org/EIPS/eip-2294) attempts to add a maximum size. Since this EIP is
stagnant, all representations of chain ids MUST be the `uint256` type.

## Interop Network Upgrade

The interop network upgrade timestamp defines the timestamp at which all functionality in this document is considered
the consensus rules for an OP Stack based network. On the interop network upgrade block, a set of deposit transaction
based upgrade transactions are deterministically generated by the derivation pipeline in the following order:

- L1 Attributes Transaction calling `setL1BlockValuesEcotone`
- User deposits from L1
- Network Upgrade Transactions
  - L1Block deployment
  - Update L1Block Proxy ERC-1967 Implementation Slot

The execution payload MUST set `noTxPool` to `false` for this block.

The exact definitions for these upgrade transactions are still to be defined.

## Derivation Pipeline

The derivation pipeline enforces invariants on safe blocks that include relaying transactions.

- The relaying message MUST have a corresponding initiating message
- The initiating message that corresponds to a relaying message MUST come from an allowed chain

Blocks that contain transactions that relay cross domain messages to the remote chain where the
initiating transaction does not exist MUST be considered invalid and MUST not be allowed by the
derivation pipeline to be considered safe.

There is no concept of replay protection within the protocol since there is no replay protection
mechanism that fits well for all applications. Users MAY submit an arbitrary number of relaying
messages per initiating message. This greatly simplifies the protocol and allows for
applications to build application specific replay protection.

### Depositing a Relaying Message

Deposit transactions (force inclusion transactions) give censorship resistance to layer two networks.
The derivation pipeline must gracefully handle the case in which a user uses a deposit transaction to
relay a cross chain message. To not couple preconfirmation security to consensus, deposit transactions
that relay cross chain messages MUST have an initiating message that is considered safe. This relaxes
a strict synchrony assumption on the sequencer that it MUST have all unsafe blocks of remote chains
as fast as possible to ensure that it is building correct blocks. It also prevents a class of attacks
where the user can send a relaying message before the initiating message and trick the derivation pipeline
into reorganizing the sequencer.

### Safety

The initiating messages for all relaying messages MUST be resolved as safe before an L2 block can transition from being unsafe to safe.
Users MAY optimistically accept unsafe blocks without any verification of the relaying messages. They SHOULD optimistically verify
the initiating messages exist in remote unsafe blocks to more quickly reorganize out invalid blocks.

## Predeploys

Two new system level predeploys are introduced for managing cross chain messaging.

### CrossL2Outbox

Address: `0x4200000000000000000000000000000000000023`

The `CrossL2Outbox` is responsible for initiating a cross chain message on the local chain.
For every cross chain message that is sent, it MUST emit an event that indicates the existence
of the cross chain message.

An initiating message 

### CrossL2Inbox

Address: `0x4200000000000000000000000000000000000022`

The `CrossL2Inbox` is responsible for relaying a cross chain message on the remote chain.
It is permissionless to finalize a cross chain message on behalf of any user. Certain protocol
enforced invariants must be preserved to ensure safety of the protocol.

### Invariants

- The timestamp of relaying message MUST be greater than or equal to the timestamp of the initiating message
- The chain id of the initiating message MUST be in the interop set
- The relaying message MUST be initiated by an externally owned account such that the top level EVM call frame enters the `CrossL2Inbox`

#### Only EOA Invariant

The `onlyEOA` invariant on relaying a cross chain message enables static analysis on relaying messages.
This allows for the derivation pipeline and block builders to reject relaying messages that do not
have a corresponding initiating message.

### L1Block

The `L1Block` contract is updated to include the set of allowed chains. The L1 Atrributes transaction
sets the set of allowed chains. The `L1Block` contract MUST provide a public getter to check is a particular
chain is in the interop set.

The `setL1BlockValuesInterop()` function MUST be called on every block after the interop upgrade block.
The interop upgrade block itself MUST include a call to `setL1BlockValuesEcotone`.

## SystemConfig

The `SystemConfig` is updated to manage the interop set. The chain operator can add or remove chains from the interop set
through the `SystemConfig`. A new `ConfigUpdate` event `UpdateType` enum is added that corresponds to a change in the interop set.

The `SystemConfig` MUST enforce that the maximum size of the interop set is `type(uint8).max` or 255.

### `INTEROP_SET` UpdateType

When a `ConfigUpdate` event is emitted where the `UpdateType` is `INTEROP_SET`, the L2 network will update its interop set.
The chain operator SHOULD be able to add or remove chains from the interop set.

## L1Attributes

The L1 Atrributes transaction is updated to include the interop set. Since the interop set is dynamically sized,
a `uint8` "interopSetSize" parameter prefixes tightly packed `uint256` values that represent each chain id.

| Input arg         | Type                    | Calldata bytes          | Segment |
| ----------------- | ----------------------- | ----------------------- | --------|
| {0x760ee04d}      | bytes4                  | 0-3                     | n/a     |
| baseFeeScalar     | uint32                  | 4-7                     | 1       |
| blobBaseFeeScalar | uint32                  | 8-11                    |         |
| sequenceNumber    | uint64                  | 12-19                   |         |
| l1BlockTimestamp  | uint64                  | 20-27                   |         |
| l1BlockNumber     | uint64                  | 28-35                   |         |
| basefee           | uint256                 | 36-67                   | 2       |
| blobBaseFee       | uint256                 | 68-99                   | 3       |
| l1BlockHash       | bytes32                 | 100-131                 | 4       |
| batcherHash       | bytes32                 | 132-163                 | 5       |
| interopSetSize    | uint8                   | 164-165                 | 6       |
| chainIds          | [interopSetSize]uint256 | 165-(32*interopSetSize) | 6+      |

## Security Considerations

### Forced Inclusion of Cross Chain Messages

The design is particular to not introduce any sort of "forced inclusion" between L2s. This design space introduces
risky synchrony assumptions and forces the introduction of a message queue to prevent denial of service attacks where
all chains in the network decide to send cross chain messages to the same chain at the same time.

### Latency

The latency at which a cross chain message is relayed from the moment at which it was initiated is bottlenecked by
the security of the preconfirmations. An initiating transaction and a relaying transaction MAY have the same timestamp,
meaning that a secure preconfirmation scheme enables atomic cross chain composability. Any sort of equivocation on behalf
of the sequencer will result in the production of invalid blocks.

### Mempool

TODO

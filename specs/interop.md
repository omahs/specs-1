# Interoperability

TODO: fault proofs section
TODO: non binding to a remote domain, allows anycast functionality
TODO:
 - rename to dependency set
 - rename local to source
 - rename remote to destination
 - block extradata needs merklized cross chain messages

The ability for a blockchain to easily read the state of another blockchain is called interoperability.
Low latency interoperability allows for horizontally scalable blockchains, a key feature of the superchain.

Note: this document references an "interop network upgrade" as a temporary name. The actual name of the
network upgrade will be included in this document in the future.

## Overview

| Term          | Definition                                               |
|---------------|----------------------------------------------------------|
| Local Chain   | A blockchain that includes an initiating message |
| Remote Chain  | A blockchain that includes a relaying message |
| Initiating Message | A transaction submitted to a local chain that authorizes execution on a remote chain |
| Relaying Message | A transaction submitted to a remote chain that corresponds to an initiating message |
| Cross Chain Message | The cumulative execution and side effects of the initiating message and relaying message |
| Interop Set | The set of chains that originate initiating transactions where the relaying transactions are valid |

A total of two transactions are required to complete a cross chain message. The first transaction is submitted
to the local chain which authorizes execution on a remote chain. The second transaction is submitted to a
remote chain, where the block builder SHOULD only include it if they are certain that the first transaction was
included in the local chain.

The term "block builder" is used interchangeably with the term "sequencer" for the purposes of this document but they need not be the same
entity in practice.

## The Interop Set

The interop set defines the set of chains that a remote chains allows as local chains. Another way of
saying it is that the interop set defines the set of initiating messages that are valid for a relaying
message to be included. A relaying message MUST have an initiating message that is included in a chain
in the interop set.

The interop set is defined by chain id. Since it is impossible to enforce uniqueness of chain ids,
social consensus MUST be used to determine the chain that represents the canonical chain id. This
particularly impacts the block builder as they SHOULD use the chain id to assist in validation
of relaying messages. 

### Chain ID

The concept of a chain id was introduced in [EIP-155](https://eips.ethereum.org/EIPS/eip-155) to prevent
replay attacks between chains. This EIP does not specify the max size of a chain id, although
[EIP-2294](https://eips.ethereum.org/EIPS/eip-2294) attempts to add a maximum size. Since this EIP is
stagnant, all representations of chain ids MUST be the `uint256` type.

## Interop Network Upgrade

The interop network upgrade timestamp defines the timestamp at which all functionality in this document is considered
the consensus rules for an OP Stack based network. On the interop network upgrade block, a set of deposit transaction
based upgrade transactions are deterministically generated by the derivation pipeline in the following order:

- L1 Attributes Transaction calling `setL1BlockValuesEcotone`
- User deposits from L1
- Network Upgrade Transactions
  - L1Block deployment
  - CrossL2Inbox deployment
  - CrossL2Output deployment
  - Update L1Block Proxy ERC-1967 Implementation Slot
  - Update CrossL2Inbox Proxy ERC-1967 Implementation Slot
  - Update CrossL2Output Proxy ERC-1967 Implementation Slot
  - Mint Cross Chain Ether Liquidity in CrossL2Inbox

The execution payload MUST set `noTxPool` to `false` for this block.

The exact definitions for these upgrade transactions are still to be defined.

## Derivation Pipeline

The derivation pipeline enforces invariants on safe blocks that include relaying transactions.

- The relaying message MUST have a corresponding initiating message
- The initiating message that corresponds to a relaying message MUST come from an allowed chain (dependency set)

Blocks that contain transactions that relay cross domain messages to the remote chain where the
initiating transaction does not exist MUST be considered invalid and MUST not be allowed by the
derivation pipeline to be considered safe.

There is no concept of replay protection within the protocol since there is no replay protection
mechanism that fits well for all applications. Users MAY submit an arbitrary number of relaying
messages per initiating message. This greatly simplifies the protocol and allows for
applications to build application specific replay protection.

### Depositing a Relaying Message

Deposit transactions (force inclusion transactions) give censorship resistance to layer two networks.
The derivation pipeline must gracefully handle the case in which a user uses a deposit transaction to
relay a cross chain message. To not couple preconfirmation security to consensus, deposit transactions
that relay cross chain messages MUST have an initiating message that is considered safe. This relaxes
a strict synchrony assumption on the sequencer that it MUST have all unsafe blocks of remote chains
as fast as possible to ensure that it is building correct blocks. It also prevents a class of attacks
where the user can send a relaying message before the initiating message and trick the derivation pipeline
into reorganizing the sequencer.

### Safety

The initiating messages for all relaying messages MUST be resolved as safe before an L2 block can transition from being unsafe to safe.
Users MAY optimistically accept unsafe blocks without any verification of the relaying messages. They SHOULD optimistically verify
the initiating messages exist in remote unsafe blocks to more quickly reorganize out invalid blocks.

## State Transition Function

After the full execution of a block, the set of `MessagePassed` events emitted from the `CrossL2Outbox` are collected and merklized.
This commitment MUST be included as the block header's [extra data field](https://github.com/ethereum/execution-specs/blob/1fed0c0074f9d6aab3861057e1924411948dc50b/src/ethereum/frontier/fork_types.py#L115).
The events are serialized with using [Simple Serialize](https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md) aka SSZ.

| Name          | Value |
|---------------|-------------------------------------|
| `MAX_LOG_DATA_SIZE` | `uint64(2**24)` or 16,777,216 |
| `MAX_MESSAGES_PER_BLOCK` | `uint64(2**20)` or 1,048,576 |

```python
class CrossChainMessage(Container):
    nonce: uint256
    sender: ExecutionAddress
    target: ExecutionAddress
    value: uint256
    timestamp: uint256
    chainid: uint256
    data: ByteList[MAX_LOG_DATA_SIZE]

messages = List[CrossChainMessage, MAX_MESSAGES_PER_BLOCK]

block.extra_data = messages.hash_tree_root()
```

## Predeploys

Two new system level predeploys are introduced for managing cross chain messaging.

### CrossL2Outbox

Address: `0x4200000000000000000000000000000000000023`

The `CrossL2Outbox` is responsible for initiating a cross chain message on the local chain.
For every cross chain message that is sent, it MUST emit an event that indicates the existence
of the cross chain message.

The event SHOULD make it as cheap as possible for the remote chain to look up the existence
of the initiating transaction when verifying the relaying transaction.

#### Initiating Messages

An initiating message emits the following event:

```solidity
event MessagePassed(
    bytes32 indexed messageHash,
    address indexed sender,
    address indexed target,
    uint256 nonce,
    uint256 value,
    uint256 timestamp,
    uint256 chainid,
    bytes data
);
```

The `messageHash` and chain id uniquely identify the existence of an initiating message and SHOULD
be used by a block builder to ensure the existence of the initiating message when verifying the relaying
transaction. `messageHash` SHOULD be `indexed` to allow for easy filtering of logs.

A cross chain message is defined in the following format:

```solidity
struct CrossChainMessage {
    uint256 nonce;
    address sender;
    address target;
    uint256 value;
    uint256 timestamp;
    uint256 chainid;
    bytes data;
}
```

Note that there is no `gasLimit` to avoid complexity with EVM gas introspection.

The `messageHash` is constructed like so:

```solidity
function hashCrossChainMessage(CrossChainMessage memory _msg) pure returns (bytes32) {
    return keccak256(abi.encode(_msg.nonce, _msg.sender, _msg.target, _msg.value, _msg.timestamp, _msg.chainid, _msg.data));
}
```

### CrossL2Inbox

Address: `0x4200000000000000000000000000000000000022`

The `CrossL2Inbox` is responsible for relaying a cross chain message on the remote chain.
It is permissionless to finalize a cross chain message on behalf of any user. Certain protocol
enforced invariants must be preserved to ensure safety of the protocol.

#### Invariants

- The timestamp of relaying message MUST be greater than or equal to the timestamp of the initiating message
- The chain id of the initiating message MUST be in the interop set
- The relaying message MUST be initiated by an externally owned account such that the top level EVM call frame enters the `CrossL2Inbox`

##### Only EOA Invariant

The `onlyEOA` invariant on relaying a cross chain message enables static analysis on relaying messages.
This allows for the derivation pipeline and block builders to reject relaying messages that do not
have a corresponding initiating message.

##### Transferring Ether in a Cross Chain Message

The `CrossL2Inbox` MUST be initially set in state with an ether balance of `type(uint256).max`.
There is no reason for a user to send [value](https://github.com/ethereum/execution-specs/blob/1fed0c0074f9d6aab3861057e1924411948dc50b/src/ethereum/frontier/fork_types.py#L53)
to the `CrossL2Inbox` so there is no need to worry about overflows. This initial balance exists to
provide liquidity for cross chain transfers of ether in a completely backwards compatible way.
The `CrossL2Inbox` MUST only transfer out ether if the caller is the `CrossL2Outbox` from a remote
chain.

#### Relaying Messages

All of the information required to satisfy the invariants MUST be included to or committed to in the calldata
of the function that is used to execute relaying messages. Both the block builder and the smart contract use
this information to ensure that all system invariants are held.

```solidity
function relayMessage(CrossChainMessage memory _msg) pure returns (bytes32) {
    require(msg.sender == tx.origin);
    require(_msg.timestamp >= block.timestamp);
    require(L1Block.isInInteropSet(_msg.chainid));

    // rest of implementation
}
```

### L1Block

The `L1Block` contract is updated to include the set of allowed chains. The L1 Atrributes transaction
sets the set of allowed chains. The `L1Block` contract MUST provide a public getter to check is a particular
chain is in the interop set.

The `setL1BlockValuesInterop()` function MUST be called on every block after the interop upgrade block.
The interop upgrade block itself MUST include a call to `setL1BlockValuesEcotone`.

## SystemConfig

The `SystemConfig` is updated to manage the interop set. The chain operator can add or remove chains from the interop set
through the `SystemConfig`. A new `ConfigUpdate` event `UpdateType` enum is added that corresponds to a change in the interop set.

The `SystemConfig` MUST enforce that the maximum size of the interop set is `type(uint8).max` or 255.

### `INTEROP_SET` UpdateType

When a `ConfigUpdate` event is emitted where the `UpdateType` is `INTEROP_SET`, the L2 network will update its interop set.
The chain operator SHOULD be able to add or remove chains from the interop set.

## L1Attributes

The L1 Atrributes transaction is updated to include the interop set. Since the interop set is dynamically sized,
a `uint8` "interopSetSize" parameter prefixes tightly packed `uint256` values that represent each chain id.

| Input arg         | Type                    | Calldata bytes          | Segment |
| ----------------- | ----------------------- | ----------------------- | --------|
| {0x760ee04d}      | bytes4                  | 0-3                     | n/a     |
| baseFeeScalar     | uint32                  | 4-7                     | 1       |
| blobBaseFeeScalar | uint32                  | 8-11                    |         |
| sequenceNumber    | uint64                  | 12-19                   |         |
| l1BlockTimestamp  | uint64                  | 20-27                   |         |
| l1BlockNumber     | uint64                  | 28-35                   |         |
| basefee           | uint256                 | 36-67                   | 2       |
| blobBaseFee       | uint256                 | 68-99                   | 3       |
| l1BlockHash       | bytes32                 | 100-131                 | 4       |
| batcherHash       | bytes32                 | 132-163                 | 5       |
| interopSetSize    | uint8                   | 164-165                 | 6       |
| chainIds          | [interopSetSize]uint256 | 165-(32*interopSetSize) | 6+      |

## Sequencer Policy

The sequencer can include relaying transactions that have corresponding initiating transactions
that only have preconfirmation levels of security if they trust the remote sequencer. Using an
allowlist and identity turns sequencing into an interated game which increases the ability for
sequencers to trust each other. Better preconfirmation technology will help to scale the sequencer
set to untrusted actors.

## Security Considerations

### Forced Inclusion of Cross Chain Messages

The design is particular to not introduce any sort of "forced inclusion" between L2s. This design space introduces
risky synchrony assumptions and forces the introduction of a message queue to prevent denial of service attacks where
all chains in the network decide to send cross chain messages to the same chain at the same time.

### Cross Chain Message Latency

The latency at which a cross chain message is relayed from the moment at which it was initiated is bottlenecked by
the security of the preconfirmations. An initiating transaction and a relaying transaction MAY have the same timestamp,
meaning that a secure preconfirmation scheme enables atomic cross chain composability. Any sort of equivocation on behalf
of the sequencer will result in the production of invalid blocks.

### Dynamic Size of L1 Attributes Transaction

The L1 Attributes transaction includes the interop set which is dynamically sized. This means that
the worst case (largest size) transaction must be accounted for when ensuring that it is not possible
to create a block that has force inclusion transactions that go over the L2 block gas limit.
It MUST be impossible to produce an L2 block that consumes more than the L2 block gas limit.
Limiting the interop set size is an easy way to ensure this.

### Maximum Size of the Interop Set

The maximum size of the interop set is constrained by the L2 block gas limit. The larger the interop set,
the more costly it is to fully verify the network. It also makes the block building role more centralized
as it requires more hardware to verify relaying transactions before inclusion.

### Mempool

Since the validation of the relaying message relies on a remote RPC request, this introduces a denial of
service attack vector. The cost of network access is magnitudes larger than in memory validity checks.
The mempool SHOULD perform cheaper checks before any sort of network access is performed. The results
of the check SHOULD be cached such that another request does not need to be performed when building the
block although consistency is not guaranteed.
